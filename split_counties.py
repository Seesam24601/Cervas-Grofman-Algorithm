#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
split_counties.py

Created by Charlie Murphy
11 September 2021

This file takes a graph of vtds in a state and a dictionary as generated by
partition_counties.py and returns a partition whose assignment follows the 
instructions made in the dictionary, with county splits performed using ReCom.
'''

from gerrychain.proposals import recom_frack
from networkx import number_connected_components
from reusable_data import get_intersections
from write_partition import write_to_csv

# split_counties
# Partition a state based on the county_assignments dictionary splitting 
# counties using Recom when necessary
def split_counties(partition, county_col, pop_col, county_assignments, epsilon,
    border_counties, border_edges, county_populations, county_subgraphs,
    max_tries):

    # Keep track of counties either placed or split
    counties = []

    # Group the nodes by county
    locality_intersections = get_intersections(partition, county_col)

    # Find the number of counties that need to be allocated. (Since every 
    # county in the state is currently is district 1, this may be less than the
    # total number of counties)
    length = len(county_assignments)

    # Loop through the counties and add counties that reside fully within one
    # district to that district
    for count, county in enumerate(county_assignments):
        county_length = len(county_assignments[county])
        if county_length == 1 and count != length - 1:
            counties.append(county)
            district = county_assignments[county][0][0]
            nodes = get_county_nodes(county_subgraphs[county], district)
            partition = partition.flip(nodes)

    # Loop through the counties again, this time dealing only with counties
    # that need to be split.
    for count, county in enumerate(county_assignments):

        county_length = len(county_assignments[county])
        if county_length > 1 or count == length - 1:

            subgraph = county_subgraphs[county]

            # Continue until the split of the county is contiguous
            tries = 0
            while True:
                proposed_partition = partition
                tries += 1

                # Loop through the districts that split the given county
                for index in range(county_length):

                    # Divide the last unallocated portion of the county between
                    # the last two districts
                    if index == county_length - 2:
                        districts = (county_assignments[county][index][0],
                            county_assignments[county][index + 1][0])
                        populations = (county_assignments[county][index][1],
                            county_assignments[county][index + 1][1])
                        subgraph_district =  get_subgraph_district(
                            proposed_partition, subgraph, 1)
                        proposed_partition = recom_frack(proposed_partition, 
                            subgraph_district, districts, populations, pop_col, 
                            epsilon)
                        break

                    # Split the county between the current district and the 
                    # unallocated portion.
                    districts = (county_assignments[county][index][0], 1)
                    district_population = county_assignments[county][index][1]
                    populations = (district_population,
                        county_populations[county] - district_population)
                    subgraph_district =  get_subgraph_district(
                            proposed_partition, subgraph, 1)
                    proposed_partition = recom_frack(proposed_partition, 
                        subgraph_district, districts, populations, pop_col, 
                        epsilon)

                # Check that the solution is contiguous. If so, keep the county
                # split.
                solution = check_all_borders(proposed_partition, border_edges, 
                    county_col, county, county_assignments, border_counties,
                    counties)

                if solution:
                    partition = proposed_partition
                    counties.append(county)
                    break

                if tries >= max_tries:
                    write_to_csv(proposed_partition, "GEOID20", "assignment", 
                        "Testing", "Test_Beta_6X")
                    return False, None
                    
    return True, partition

# Get County nodes
# Returns all of the nodes in a particular county
def get_county_nodes(subgraph, district):
    
    nodes = dict()

    for x in subgraph:
        nodes[x] = district

    return nodes

# get_subgraph_district
# Return the collection of nodes within a county that are in a given district.
def get_subgraph_district(partition, subgraph, district):
    county_subgraph = set()

    for node in subgraph:
        if partition.assignment[node] == district:
            county_subgraph.add(node)

    subgraph = partition.graph.subgraph(county_subgraph)
    return subgraph

# check_borders
# For a given county and bordering county, check that there exists an edge in 
# where the node in the county is of the given district
def check_borders(partition, border_edges, county_col, district, county,
    border_county, counties):

    # Find the edges between the county and border county from the border_county
    # dictionary
    if (county, border_county) in border_edges:
        edges = border_edges[(county, border_county)]
    else:
        edges = border_edges[(border_county, county)]

    # Loop through the edges
    for edge in edges:
        edge_districts = (partition.assignment[edge[0]], 
            partition.assignment[edge[1]])
        edge_counties = (partition.graph.nodes()[edge[0]][county_col],
            partition.graph.nodes()[edge[1]][county_col])

        # Check to see if one of the edges meets the criteria
        for i in range(2):
            if (edge_counties[i] == county and
                edge_districts[i] == district):

                # If the border_county has already been partitioned, check that
                # the edge is the district on both sides
                if border_county in counties:
                    if edge_districts[i - 1] == district:
                        return True
                else:
                    return True

    return False

# check_all_borders
# Check that all borders within a given county meet the requirements in 
# county_assignments such that a valid partition of the entire map is possible
def check_all_borders(partition, border_edges, county_col, county, 
    county_assignments, border_counties, counties):

    # Find the counties that border the given county
    for pair in border_counties:
        for i in range(2):
            if county == pair[i]:

                # For each bordering county, check to see if there exists a
                # district within both the county and the bodering county
                if pair[i - 1] in county_assignments:
                    for d1 in county_assignments[pair[i - 1]]:
                        for d2 in county_assignments[county]:
                            if d1[0] == d2[0]:

                                # If such a district exists, check that there
                                # is a valid border between them
                                if not check_borders(partition, border_edges, 
                                    county_col, d1[0], county, pair[i - 1],
                                    counties):
                                        return False

    return True